#include "SeapodymCoupled.h"


//temporal: test
double SUM_CATCH;


//////////////////////////////////////////////////////////////////
//--------------------------------------------------------------//
//		     FORAGE-TUNA SIMULATION			//
//--------------------------------------------------------------//
//////////////////////////////////////////////////////////////////
/*!
\brief The tuna population simulation loop is in this function.
*/
double SeapodymCoupled::OnRunCoupled(dvar_vector x, const bool writeoutputfiles)
{
SUM_CATCH = 0.0;
	InitializeAll();

	past_month=month;
	past_qtr=qtr;

	//Temporarily reading the tau of the first cohort
	//Need to be just a single number for all cohorts
	int dtau = param->sp_unit_cohort[0][1];
	int nbt_before_first_recruitment = Date::get_nbt_before_first_recruitment(
			param->first_recruitment_date,
			param->ndatini,param->deltaT,param->date_mode); 	
	//counter of number of time steps between recruitments (survival equations)
	//once nt_dtau = dtau, recruitment occurs and nt_dtau=0
	//its initial value is dtau-nbt_before_first_recruitment_date
	int nt_dtau = dtau-nbt_before_first_recruitment; 

	//routine-specific variables
	int tcur = t_count; //will be used for forcing variable time control
	int nbt_no_forecast = t_count + nbt_spinup_tuna + nbt_total - 1;
	bool fishing = false;
	int migration_flag = 0;
	int step_count= 0;
	int step_fishery_count= 0;
	int jday = 0; 
	int nt_yn = 1000; // time of recruitment to the first young cohort
	int nbstoskip = param->nbsteptoskip; // nb of time step to skip before computing likelihood
	ivector Nobs(0,nb_fishery-1); Nobs.initialize();

	if (!param->gcalc()){
		//need to read oxygen in case if month==past_month
		//(otherwise we may not have it for the first time steps)
		if (param->type_oxy==1 && month==past_month)
			ReadClimatologyOxy(1, month);
		//need to read oxygen in case if qtr==past_qtr 
		if (param->type_oxy==2 && qtr==past_qtr)
			ReadClimatologyOxy(1, qtr);
	}


//SODA from ERA40:
//SaveDistributions(true,year,month);
//exit(1);
	alike = 0.0;
	dvariable likelihood = 0.0;
	reset(x);
	//----------------------------------------------//
	// 	LOCAL MATRICES ALLOCATION SECTION       //
	//----------------------------------------------//	
	dvar_matrix Spawning_Habitat;
	dvar_matrix Total_pop;
	dvar_matrix mature_fish, immature_fish;
	dvar_matrix Habitat; 
	dvar_matrix IFR; 
	dvar_matrix ISR_denom; 
	dvar_matrix FR_pop;
	dvar_matrix Mortality; 

	Habitat.allocate(map.imin1, map.imax1, map.jinf1, map.jsup1);
	Mortality.allocate(map.imin, map.imax, map.jinf, map.jsup);
	Spawning_Habitat.allocate(map.imin, map.imax, map.jinf, map.jsup);
	Total_pop.allocate(map.imin, map.imax, map.jinf, map.jsup);
	mature_fish.allocate(map.imin1, map.imax1, map.jinf1, map.jsup1);
	immature_fish.allocate(map.imin1, map.imax1, map.jinf1, map.jsup1);

	if (param->food_requirement_in_mortality(0)){ 
		//temporal, need to check memory use first 
		IFR.allocate(map.imin, map.imax, map.jinf, map.jsup);
		ISR_denom.allocate(map.imin, map.imax, map.jinf, map.jsup);
		FR_pop.allocate(map.imin, map.imax, map.jinf, map.jsup);
		IFR.initialize();
		ISR_denom.initialize();
		FR_pop.initialize();
	}
	Spawning_Habitat.initialize();
	Habitat.initialize();
	Mortality.initialize();
	mature_fish.initialize();
	immature_fish.initialize();

///READ and INITIALIZE tagging data class
int dt = (mat.zlevel[1]-mat.zlevel[0])*365.25; //TEMP
//cout << dt << endl;

	//precompute thermal habitat parameters
	for (int sp=0; sp < nb_species; sp++)
		func.Vars_at_age_precomp(*param,sp);

	//precompute seasonal switch function
	for (int sp=0; sp < nb_species; sp++){
		if (param->seasonal_migrations[sp]){
			func.Seasonal_switch_year_precomp(*param,mat,map,
						value(param->dvarsSpawning_season_peak[sp]),
						value(param->dvarsSpawning_season_start[sp]),sp);
		}
	}

	//STOCK likelihood
	double stocklike = 0.0;
	dvariable total_stock = 0.0;

	double taglike = 0;

	//TAG vars initialization section
	tags_age_habitat.initialize();
	if (nb_tagpops>0){
		tagpop_age_solve.initialize();
		rec_pred.initialize();
	}
	//TAG data reading and allocation section
/*	imatrix nb_rel;
	ivector t_count_rec;
	nb_tagpops = param->nb_tag_files;

	if (param->tag_like[0]){
		nb_rel.allocate(0,nb_tagpops-1);
		for (int n=0; n<nb_tagpops; n++){	
			nb_rel(n).allocate(0,nbt_total-1);
			nb_rel(n).initialize();
		}
		create_tag_recaptures();
		ReadTaggingData(nb_rel, t_count_rec);
	}
	ivector  tags_age_habitat;
	tags_age_habitat.allocate(0,aN_adult(0));
	i3_array tagpop_age_solve;
	tagpop_age_solve.allocate(0,nb_tagpops-1);
	for (int p=0; p<nb_tagpops; p++){
		tagpop_age_solve(p).allocate(0,nbt_total);
		for (int n=0; n<nbt_total+1; n++){
			tagpop_age_solve(p,n).allocate(0,aN_adult(0));
			tagpop_age_solve(p,n).initialize();
		}
	}
	//END of TAG data reading and allocation 
*/
	//Average selectivity: not permanent at the moment
/*	if (writeoutputfiles){
                ivector ps_fishery;
                ps_fishery.allocate(0,nb_fishery-1);
                ps_fishery.initialize();
                ps_fishery(12) = 1;//S13
                ps_fishery(13) = 1;//S14
                ps_fishery(14) = 1;//S15
                ps_fishery(15) = 1;//S16
                ps_fishery(16) = 1;//S17
                ps_fishery(17) = 1;//S18
                for (int sp=0; sp<nb_species; sp++){
			int nb_ages = param->sp_nb_cohorts[sp];
        		swa.allocate(0,nb_species-1,0,nb_ages-1);
        		swa(0) = 1;
			rw.get_average_selectivity(map, *param, swa(sp), ps_fishery, nb_fishery, nbt_total-1, nb_ages, sp, 0);
		}
	}	
*/	
	if (writeoutputfiles){
		WriteFileHeaders();
		if (!param->gcalc())
			ConsoleOutput(0,0);
	}
	bool tags_only = param->tags_only;
	int spop0 = 0;
	int mortality_off = 0;
	if (tags_only) {
		spop0 = 1;
		nb_fishery = 0;
		fishing = false;
		param->stock_like.initialize();
		param->frq_like.initialize();
	}

	//------------------------------------------------------//
	//	   COMPUTE FLUXES BETWEEN REGIONS		//
	//------------------------------------------------------//
	int comp_fluxes  = 1;//first code version, where they were implemented in G
	writeoutputfiles = 1;
	param->frq_like[0] = 0;
	if (param->nb_region==0){
		CERR << "In FLUXES mode the regional structure MUST be defined and activated. Revise the parfile, will stop now!" << endl;
		exit(1);
	}


	/////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////
	////------------------------------------------------------------/////
	////								/////
	////		||| START OF SIMULATION CYCLE |||		/////
	////								/////
	////------------------------------------------------------------/////
	/////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////

	//Add penalty function to the likelihood for sum(eF_habitat)<eF_sum
	double eFlike = 0.0;
/*	if (param->tag_like[0]){
		dvariable dvarEF_sum = sum(param->dvarsEF_habitat);
		likelihood -= 1e1*log(eF_sum-dvarEF_sum);
		eFlike -= 1e1*log(eF_sum - value(dvarEF_sum));
	}
*/
	for (;t_count <= nbt_total; t_count++)
	{

//TRACE(t_count)
//	param->dvarsB_sst_larvae[0] += 2.0/nbt_total; //CC-ST, 2C increase of spawning optimum
//	param->dvarsB_sst_larvae[0] += 2.0/1080 ;//nbt_total=90*12 (2011:2100); //CC-ST, 2C increase of spawning optimum by the end of 2100
		
		//----------------------------------------------//
		//              INITIALISATION                  //
		//----------------------------------------------//
		sumP=0;
		sumFprime.initialize();
		sumF.initialize();
		mat.dvarCatch_est.initialize();
		if (param->tag_like[0]){
			get_tag_releases(mat.dvarDensity,tagpop_age_solve,nb_rel);
			tags_age_habitat.initialize();
			for (int spop=1; spop<nb_tagpops+1; spop++){
				for (int a=a0_adult(0); a<aN_adult(0); a++){
					//first initialize with the ages, which will be resolved
					tags_age_habitat[a] += tagpop_age_solve(spop-1,t_count-1,a);
				}
			}
			//second correct by the age_compute_habitat indices
			for (int a=a0_adult(0); a<aN_adult(0); a++){
				if (tags_age_habitat[a]){
					int aa = a;
					for (; aa>=a0_adult(0); aa--){
						if (param->age_compute_habitat(0,aa)!=param->age_compute_habitat(0,aa-1))
							break;
					}
					if (!tags_age_habitat[aa]) tags_age_habitat[aa] = -1;
				}
			}
		}
		//cout << sum(tags_age_habitat) << ": " << tags_age_habitat << endl; 
		//----------------------------------------------//
		//			DATE			//
		//----------------------------------------------//
		getDate(jday);
		for (int sp=0; sp < nb_species; sp++){
			func.Seasonal_switch(*param,mat,map,jday,sp);	
		}
		tcur = t_count;
		if (!param->gcalc()){
			tcur = 1; 
			//----------------------------------------------//
			//	DATA READING SECTION: U,V,T,O2,PP	//
			//----------------------------------------------//
			//if ((t_count > nbt_building)) { //CC run with average effort forecast
			if ((t_count > nbt_building) && (t_count <= nbt_no_forecast)) {
				//TIME SERIES 
				t_series = t_count - nbt_building + nbt_start_series;
				ReadTimeSeriesData(tcur,t_series);	
	
			}
			//else if (((t_count <= nbt_building) && (month != past_month))) { //CC run with average effort forecast
			else if (((t_count <= nbt_building) && (month != past_month)) || (t_count > nbt_no_forecast)) {
	
				//AVERAGED CLIMATOLOGY DATA
				ReadClimatologyData(tcur, month);
			}
			if (param->type_oxy==1 && month != past_month) {
				//MONTHLY O2
				ReadClimatologyOxy(tcur, month);
			}
			if (param->type_oxy==2 && qtr != past_qtr) {
				//QUARTERLY O2
				ReadClimatologyOxy(tcur, qtr);
			}
		}
		//----------------------------------------------//
		//	READING CATCH DATA: C_obs, effort	//
		//----------------------------------------------//
		if (!tags_only && (nb_fishery > 0) && sum(param->mask_fishery_sp) && ( t_count > nbt_building) 
				&& (year>=(int)param->save_first_yr) && (t_count <= nbt_no_forecast) ){
			mat.catch_est.initialize();
			rw.get_fishery_data(*param, mat.effort, mat.catch_obs, mat.efflon, mat.efflat, year, month);
			fishing = true;
			if (qtr != past_qtr){
				mat.C_N_sp_age_fishery.initialize();
				mat.dvarLF_est.initialize();
				if (t_count > nbt_building+nbstoskip){
					rw.get_LF_qtr_data(*param, mat.LF_qtr_obs, year, qtr-1);
				}
			}
		}
/*
		if (param->mpa_simulation){
			rw.get_fishery_data_mpa(map,*param, mat.effort, mat.catch_obs, year, month);
		}
*/
                if (param->mpa_simulation){
                        rw.get_fishery_data_mpa(map,*param, mat.effort, mat.catch_obs, mat.efflon, mat.efflat, year, month);
			
			//test: for 'no effort' fisheries use effort multipliers for catch
		/*	int k = 0;
			for (int f=0; f<nb_fishery; f++){ 
				if (param->mask_fishery_sp[0][f]){
					if (param->mask_fishery_sp_no_effort[0][f]){
						rw.inc_obs_catch_mpa(map,*param,mat.catch_obs[0][k],0);
					}
					k++;
				}
			}
		*/	
                }

		if (t_count > nbt_no_forecast) {
			rw.get_average_effort(*param, mat.effort, mat.efflon, mat.efflat, 10, month);
			//to get actual fishing data if it exists
			//rw.get_fishery_data(*param, mat.effort, mat.catch_obs, year, month);
			mat.catch_obs.initialize();
			mat.catch_est.initialize();
			mat.C_N_sp_age_fishery.initialize();
			mat.dvarLF_est.initialize();
		}
		//----------------------------------------------//
		//	 SOME MORE SIMULATION VARIABLES		//
		//----------------------------------------------//
		int pop_built = 0; 
		if (t_count > nbt_building) 
			pop_built = 1;
		//------------------------------------------------------------------------------//
		//	TRANSPORT OF TUNA AGE CLASSES AND PREDICTED CATCH COMPUTATION		//
		//------------------------------------------------------------------------------//
		//------------------------------------------------------------------------------//
		mat.u = mat.un[tcur][0]; mat.v = mat.vn[tcur][0]; 
		pop.precaldia(*param, map, mat);
		pop.caldia(map, *param, mat.diffusion_x, mat.advection_x, mat.diffusion_y, mat.advection_y);
		for (int sp=0; sp < nb_species; sp++){
			//store fish density before transport
			for (int a=a0_adult(sp); a<aN_adult(sp); a++)
				mat.density_before(sp,tcur,a) = value(mat.dvarDensity(sp,a));

			//1. Precompute some variables outside of age loop

			//1.1 Accessibility by adults (all cohorts)
 			func.Faccessibility(*param, mat, map, sp, jday, tcur, pop_built, tags_only, tags_age_habitat);//checked

			//1.2 Food Requirement by population
			if (param->food_requirement_in_mortality(sp)){
				FR_pop_comp(FR_pop, sp);
//				ISR_denom_comp(ISR_denom, sp, tcur);
			}
			//1.3 precompute local proportions of catch by fishery
			if (fishing && param->fisheries_no_effort_exist[sp]){
				pop.Ctot_proportion_fishery_comp(map,*param,mat,rw,year,month,sp);
			}
			//1.4 precompute selectivity functions
			if (fishing)
				pop.Selectivity_comp(*param,nb_fishery,a0_adult(sp),aN_adult(sp),sp);
//connectivity simulations:
//Bismarck Sea, mask file po_soda_v2_opsat_mask_eez_PNG-AW_HSP.txt, ID=-92 
//Bismarck Sea, mask file mask_ecco_PNG_AW.txt ID=-2 
//Mariana Islands, mask file mask_Guam_NMI.txt, ID=-8 
/*
int reg = 7;
for (int i = map.imin; i <= map.imax; i++){
        const int jmin = map.jinf[i];
        const int jmax = map.jsup[i]; 
        for (int j = jmin; j <= jmax; j++){
                if (map.carte(i,j)){ 
//if (t_count==1){

                        //1. No recruitment in EEZ
                        //if (map.maskEEZ[i][j] == -92){
                        if (map.maskEEZ[i][j] == -2){
                              for (int a=a0_adult(sp); a<aN_adult(sp); a++)
                                     if (a>=param->age_mature[sp])
                                            mat.dvarDensity(0,a,i,j) = 0.0;

                         //      for (int a=0; a<=param->age_recruit[sp]; a++)
			 //	       mat.dvarDensity(0,a,i,j) = 0.0;
                        }

//}

			//2. No recruitment outsize of EEZ
                        if (map.maskEEZ[i][j] != -8){
                              if (i>=map.regimin[reg] && i<map.regimax[reg] && 
                                  j>=map.regjmin[reg] && j<map.regjmax[reg]){
				      for (int a=0; a<=param->age_recruit[sp]; a++)
                                      	mat.dvarDensity(0,0,i,j) = 0.0;
			      }
			      
                              if (i>=map.regimin[5] && i<map.regimax[5] && 
                                  j>=map.regjmin[5] && j<map.regjmax[5]){
				      for (int a=0; a<=param->age_recruit[sp]; a++)
                                      	mat.dvarDensity(0,0,i,j) = 0.0;
			      }
                        }
			
			
                }
        }
}*/
/*
//connectivity simulations:
//SKJ Range Contraction with 2016-2017 regional structure
int reg;
for (int i = map.imin; i <= map.imax; i++){
        const int jmin = map.jinf[i];
        const int jmax = map.jsup[i]; 
        for (int j = jmin; j <= jmax; j++){
                if (map.carte(i,j)){ 
			reg = 15;
                        if (i>=map.regimin[reg] && i<map.regimax[reg] && 
                        	j>=map.regjmin[reg] && j<map.regjmax[reg]){
                        	//for (int a=0; a<=param->age_recruit[sp]; a++)
                        	for (int a=param->age_recruit[sp]+1; a<param->sp_nb_cohorts[sp]; a++)
					if (a>=param->age_mature[sp])
                                        	mat.dvarDensity(0,a,i,j) = 0.0;
                        } 
			reg = 14;
                        if (i>=map.regimin[reg] && i<map.regimax[reg] && 
                        	j>=map.regjmin[reg] && j<map.regjmax[reg]){
                        	for (int a=0; a<=param->age_recruit[sp]; a++)
                        	//for (int a=param->age_recruit[sp]+1; a<param->sp_nb_cohorts[sp]; a++)
				//	if (a<param->age_mature[sp])
                                        	mat.dvarDensity(0,a,i,j) = 0.0;
                        } 
			reg = 12;
                        if (i>=map.regimin[reg] && i<map.regimax[reg] && 
                        	j>=map.regjmin[reg] && j<map.regjmax[reg]){
                        	//for (int a=0; a<=param->age_recruit[sp]; a++)
                        	for (int a=param->age_recruit[sp]+1; a<param->sp_nb_cohorts[sp]; a++)
					if (a>=param->age_mature[sp])
                                        	mat.dvarDensity(0,a,i,j) = 0.0;
                        } 			
                }
        }

}
*/
//With MFCL-2015 regional structure (used in Seapodym_cltags paper)
/*int reg = 0;
for (int i = map.imin; i <= map.imax; i++){
        const int jmin = map.jinf[i];
        const int jmax = map.jsup[i]; 
        for (int j = jmin; j <= jmax; j++){
                if (map.carte(i,j)){ 
                        //No recruitment/Young/Adult in region
                        if (i>=map.regimin[reg] && i<map.regimax[reg] && 
                                j>=map.regjmin[reg] && j<map.regjmax[reg]){
                                //for (int a=0; a<=param->age_recruit[sp]; a++)
                                for (int a=param->age_recruit[sp]+1; a<param->sp_nb_cohort_ad[sp]; a++)
                                        if (a>=param->age_mature[sp])
                                                mat.dvarDensity(0,a,i,j) = 0.0;
                        } 
                }
        }

}	
*/

			//2. Starting cohort computation (implicit age loop) 
			int age = 0;	
			//2.1 Spawning habitat	
			if (!tags_only)
			func.Spawning_Habitat(*param, mat, map, Spawning_Habitat, 1.0, sp, tcur, jday);
			//2.2 Transport and mortality of larvae	
			for (int n=0; n<param->sp_nb_cohort_lv[sp]; n++){
				double mean_age = mean_age_cohort[sp][age]; 
				if (!tags_only){
				func.Mortality_Sp(*param, mat, map, Mortality, Spawning_Habitat, sp, mean_age, age, tcur);
				pop.Precalrec_juv(map, mat, Mortality, tcur, pop_built);//checked
				pop.Calrec_juv(map, mat, mat.dvarDensity[sp][age], Mortality, tcur, pop_built);//checked
				}
				age++;
			}
			///if (t_count > nbt_spinup_forage + nt_jv){ SPINUP TO BE FIXED!!!
				//2.3. Juvenile habitat	
				if (!tags_only){
				if (param->cannibalism[sp]){
					Total_Pop_comp(Total_pop,sp,jday,tcur); //adjoint
					func.Juvenile_Habitat_cannibalism(*param, mat, map, Habitat, Total_pop, sp, tcur, pop_built);
				} else 
					func.Juvenile_Habitat(*param, mat, map, Habitat, sp, tcur, pop_built);
				}
				//2.4. Transport and mortality of juvenile age classes	
				for (int n=0; n<param->sp_nb_cohort_jv[sp]; n++){			
					double mean_age = mean_age_cohort[sp][age];
					if (!tags_only){
					func.Mortality_Sp(*param, mat, map, Mortality, Habitat, sp, mean_age, age, tcur);
					pop.Precalrec_juv(map,  mat, Mortality, tcur, pop_built);
					pop.Calrec_juv(map, mat, mat.dvarDensity[sp][age], Mortality, tcur, pop_built);
					}
					age++;
				}
			///} 
				//----------------------------------------------//
				//	    Fishing with a given effort		//
				//----------------------------------------------//
				//3. Compute predicted catch before transport & mortality	
				if (fishing){
					int k = 0;
					for(int f=0; f<nb_fishery; f++){
						if (param->mask_fishery_sp[sp][f]){
							//Inna 11/12/2013: no computation of predicted catch 
							//and LF in optimization mode for fisheries, 
							//which are not augmented to the likelihood
							if (param->gcalc()){
								if (param->mask_fishery_sp_like[sp][f] && !param->mask_fishery_sp_no_effort[sp][f])
									pop.Predicted_Catch_Fishery(map,*param,mat,rw,sp,f,k,year,month,tcur,step_fishery_count);
							} else {
								if (!param->mask_fishery_sp_no_effort[sp][f])
									pop.Predicted_Catch_Fishery(map,*param,mat,rw,sp,f,k,year,month,tcur,step_fishery_count);
							}
							
							k++;
						}
					}
					step_fishery_count++;
				}
				if (fishing && param->fisheries_no_effort_exist(sp))
					pop.Total_exploited_biomass_comp(map,*param,mat,sp,tcur);
/*//SAVE-BEFORE-FISHING code starts here, keep this block commented when NOT USED 
dvar3_array Pop_copy;
const int agemax_ad = param->sp_nb_cohorts[0];
Pop_copy.allocate(0, agemax_ad - 1);
for (int age = 0; age < agemax_ad; age++) {
	Pop_copy(age).allocate(map.imin1, map.imax1, map.jinf1, map.jsup1);
	Pop_copy(age).initialize();
}
for (int icounter=0; icounter<2; icounter++){
	if (icounter==0){
		fishing = false;
		Pop_copy = mat.dvarDensity[0]; 
	}
	if (icounter==1){ 		
		fishing = true;
		age = param->sp_nb_cohort_jv[sp]+1;
		mat.dvarDensity[0].initialize();
		mat.dvarDensity[0] = Pop_copy;
	}
//end of the first block of 'SAVE-BEFORE-FISHING'
*/	
			//4. Transport and mortality of adult cohort
			///if (t_count > nbt_spinup_forage + nt_yn){ TO BE FIXED!!!
				///for (int age=0; age<=nb_age_built[sp]; age++){///TO BE FIXED!!!	
				for (int n=0; n<param->sp_nb_cohort_ad[sp]; n++){

					if (fishing && param->fisheries_no_effort_exist(sp))
						pop.Total_obs_catch_age_comp(map,*param,mat,rw,age,sp,year,month,tcur);


					//NOTE: currently current averaging doesn't depend on seasonal migrations
					if (param->vert_movement[sp] && param->age_compute_habitat[sp][age]!=param->age_compute_habitat[sp][age-1]){
						if (!tags_only || tags_age_habitat(age))
							func.Average_currents(*param, mat, map, age, tcur, pop_built);
					}
					
					//2014: catch at age computation for fisheries without effort data
					//pop.Ctot_no_effort_sp_age_comp(map, *param, mat, value(mat.dvarDensity(sp,age)), tcur, sp, age);				
					//this section will work only if seasonality switch is ON 
					//and for <1 maturity at age parameter
					if (param->migrations_by_maturity_flag && param->seasonal_migrations[sp]){
						cout << "In this version no smooth maturity; enter the age at first maturity. Exit now!" << endl; exit(1);
					
					} // end of section with seasonality switch and <1 maturity at age parameter 
					else {
						migration_flag = 0;
						if (age>=param->age_mature[sp] & param->seasonal_migrations[sp]) migration_flag = 1;
//cout << age << " " << param->age_mature[sp] << " " << migration_flag << endl;						

						if (param->age_compute_habitat[sp][age]!=param->age_compute_habitat[sp][age-1]) {
							if (!tags_only || tags_age_habitat(age))
								func.Feeding_Habitat(*param,mat,map,Habitat,sp,age,jday,tcur,migration_flag);
						}
						double mean_age = mean_age_cohort[sp][age];

						if (!param->food_requirement_in_mortality(sp)){
							func.Mortality_Sp(*param, mat, map, Mortality, Habitat, sp, mean_age, age, tcur);//checked
						} else {
							Food_Requirement_Index(IFR, FR_pop, ISR_denom, sp, age, tcur, jday);
							func.Mortality_Sp(*param, mat, map, Mortality, IFR, sp, mean_age, age, tcur);//checked
						}
						//Compute fluxes here
						FluxesComp(mat.dvarDensity(sp,age), Habitat, Mortality, age, fishing, year, month, jday, step_fishery_count,tcur, pop_built);

						if (param->age_compute_habitat[sp][age]!=param->age_compute_habitat[sp][age-1]){
							if (!tags_only || tags_age_habitat(age))
								pop.Precaldia_Caldia(map, *param, mat, Habitat, Total_pop, sp, age, tcur, pop_built,jday);//checked	
						}
						if (!param->gcalc()){
							// only in simulation mode: compute mean speed 
							// in BL/sec and mean diffusion rate in nmi^2/day
							mat.MeanVarMovement(map,value(mat.dvarsAdvection_x),
								value(mat.dvarsAdvection_y),
				 				value(mat.dvarsDiffusion_y),
								param->MSS_species[sp],
								param->sigma_species[sp],
								param->length(sp,age),
								param->length(sp,param->sp_nb_cohorts[sp]-1),
								deltaT,sp,age);
						}
						
						//store adult habitat and update the counter
						if (param->age_compute_habitat[sp][age]!=param->age_compute_habitat[sp][age-1]){
							//cout << age << " " << param->age_compute_habitat[sp][age] << endl;
							mat.adult_habitat(sp,tcur,param->age_compute_habitat[sp][age]) = value(Habitat);
						}
						for (int spop=spop0; spop<nb_tagpops+1; spop++){
							mortality_off = 0;
//SAVE-BEFORE-FISHING: comment the two lines below if USED:						
							if (sum(param->mask_fishery_sp) && !tags_only)
								fishing = true;

							if (spop>0) { 
								Mortality.initialize();
								mortality_off = 1;
								if (fishing) fishing = false;
							}
							if (spop>0){
							   if (!tagpop_age_solve(spop-1,t_count-1,age))
								continue;
							}
							pop.Precalrec_Calrec_adult(map,mat,*param,rw,
								mat.dvarDensity[spop][age],Mortality,
								tcur,pop_built,fishing,age,sp,year,month,
								jday,step_fishery_count,mortality_off);//checked 20150210
						}
//SAVE-BEFORE-FISHING: comment the line below if USED:						
						if (sum(param->mask_fishery_sp) && !tags_only) fishing = true;
					}
					age++;
				}
//SAVE-BEFORE-FISHING: comment two lines below when NOT USED!
//if (icounter==0)//save without fishing
//	CalcSums(); //comment the CalcSums below!

//SAVE-BEFORE-FISHING: comment the closing below when NOT USED
//}
			//----------------------------------------------//
			//  Now compute predicted catch without effort 	//
			//----------------------------------------------//
			if (fishing && param->fisheries_no_effort_exist(sp))
				pop.Predicted_Catch_Fishery_no_effort(map,*param,mat,rw,sp,year,month);

			//store fish density after transport and mortality
			for (int a=0; a<aN_adult(sp); a++)
				mat.density_after(sp,a) = value(mat.dvarDensity(sp,a));
			if (writeoutputfiles){
				CalcMeanTemp(t_count,tcur);
//SAVE-BEFORE-FISHING: comment the CalcSums here if USED!				
				CalcSums();
			}
			//Compute total stock before the new recruitment (survival)
			if (param->stock_like[sp] && t_count > nbt_building+nbstoskip)
				Total_Stock_comp(total_stock, sp);

			//5. Spawning	
			if (!tags_only)
			SpawningBiomass_comp(Total_pop, sp);
			//----------------------------------------------//
			//	    TUNA AGEING AND SPAWNING		//
			//----------------------------------------------//

			//6. Ageing and survival
			///for (int a=nb_age_built[sp]; a >= 1; a--){TO BE FIXED!!!
			if (nt_dtau==dtau){
				for (int a=param->sp_nb_cohorts[sp]-1; a >= 1; a--){
					for (int spop=spop0; spop<nb_tagpops+1; spop++){
						if (spop>0){
							if (tagpop_age_solve(spop-1,t_count-1,a-1)==1){					
								tagpop_age_solve(spop-1,t_count,a-1)=0;
								tagpop_age_solve(spop-1,t_count,a)=1;
							}
						}
//cout << t_count << " ageing!!! " << a << endl;
						Survival(mat.dvarDensity[spop][a], mat.dvarDensity[spop][a-1] , a, sp);
					}
				}
				nt_dtau=0;
				//mat.dvarDensity[sp][0].initialize();
			}
			//to test sst function for the spawning habitat (i.e. no match-mismatch mechanism)
			//func.SST_Habitat(*param, mat, map, Spawning_Habitat, sp, data_fpos, pop_built);
			if (!tags_only)
				Spawning(mat.dvarDensity[sp][0],Spawning_Habitat,Total_pop,jday,sp,pop_built,tcur);//checked

//			if (writeoutputfiles)
//				CalcSums();

//cout << tcur << endl;
		}//end of 'sp' loop
//cout << sum(mat.dvarDensity[1]) << ": ";
//for (int aa=10; aa<aN_adult[0]; aa++) cout << sum(mat.dvarDensity(1,aa)) << " ";
//cout << endl;
		//------------------------------------------------------//
		//		COMPUTING LIKELIHOOD			//
		//------------------------------------------------------//
		//LIKELIHOODs COMPUTATION
		//I. Total abundance likelihood
		if (t_count <= nbt_total){
			if (t_count == nbt_total){
		    	    for (int sp=0; sp < nb_species; sp++){
				//cout << "sum(eF): " << sum(value(param->dvarsEF_habitat))<<"; ";
				if (!param->stock_like[sp] & !param->scalc()) cout << endl;
				if (param->stock_like[sp]){
					cout << "stock size: " << total_stock << endl;
					//double mean_total_stock_obs = 12.5e3; //total PO stock in 1000 thous. mt 
					double mean_total_stock_obs = param->mean_stock_obs[sp];  
					likelihood += (total_stock-mean_total_stock_obs)*(total_stock-mean_total_stock_obs);
					stocklike += value((total_stock-mean_total_stock_obs)*(total_stock-mean_total_stock_obs));
					//likelihood -= 100.0*log(mean_total_stock_obs-total_stock);
					//stocklike -= value(100.0*log(mean_total_stock_obs-total_stock));
				}
			    }
			}		    
		}
		
		//II. Tag data likelihood
		if (param->tag_like[0]){
			if (month==1 || month==4 || month==7 || month==10){
				rec_obs_like.initialize();
				rec_pred_like.initialize();
			        mat.total_obs_catch.initialize();
				mat.total_pred_catch.initialize();
			}
/*const int imin = map.imin; 
const int imax = map.imax; 			
for (int i = imin; i <= imax; i++){
	const int jmin = map.jinf[i];
	const int jmax = map.jsup[i];
	for (int j = jmin ; j <= jmax; j++){
		if (map.carte[i][j] && (i>=60 && i<=62 && j>=31 && j<=32)){
			double xx = param->itolon(i);
			double yy = param->jtolat(j);
			for (int ii=0; ii<nx_obs; ii++)
			for (int jj=0; jj<ny_obs; jj++){
				if (xx>xlon[ii] && xx<=xlon[ii+1]&& yy<=ylat[jj] && yy>ylat[jj+1]){			
					cout << i << " "<< j << " "<< xx << " "<< yy << " " << ii << " " << jj << endl;

				}
			}
		}
	}
} exit(1);
*/
			for (int p=0; p<nb_tagpops; p++){
			    int nb_obs = 0;
			    if (t_count==t_count_rec(p)){

//TTTRACE(p,t_count,sum(rec_obs(p)))			    
				const int imin = map.imin; 
				const int imax = map.imax; 
				for (int i = imin; i <= imax; i++){
					const int jmin = map.jinf[i];
					const int jmax = map.jsup[i];
					for (int j = jmin ; j <= jmax; j++){
						if (map.carte[i][j]){
										
							double xx = param->itolon(i);
							double yy = param->jtolat(j);
							for (int ii=0; ii<nx_obs; ii++)
							for (int jj=0; jj<ny_obs; jj++){
								if (xx>xlon[ii] && xx<=xlon[ii+1]&& yy<=ylat[jj] && yy>ylat[jj+1]){
									for (int aa=a0_adult[0]; aa<aN_adult[0]; aa++)
										rec_pred(p,ii,jj) += mat.dvarDensity(p+1,aa,i,j)*cell_area/mat.lat_correction(j);
										//rec_pred(p,ii,jj) += 0.001*mat.dvarDensity(p+1,aa,i,j);
								}	
							}
						}
					}
				}
				//temporally write recaptures to catch matrix (comment in CalcSums)
				for (int i = imin; i <= imax; i++){
					const int jmin = map.jinf[i];
					const int jmax = map.jsup[i];
					for (int j = jmin ; j <= jmax; j++){
						if (map.carte[i][j]){
							double xx = param->itolon(i);
							double yy = param->jtolat(j);
							if (writeoutputfiles){
								for (int ii=0; ii<nx_obs; ii++)
								for (int jj=0; jj<ny_obs; jj++){
									if (xx>xlon[ii] && xx<=xlon[ii+1]&& yy<=ylat[jj] && yy>ylat[jj+1]){	
										mat.total_obs_catch(0,i,j) = rec_obs(p,ii,jj)/(xr_tags*yr_tags);
										mat.total_pred_catch(0,i,j)= value(rec_pred(p,ii,jj))/(xr_tags*yr_tags);
									}
								}
							}
						}
					}
				}
				
				//TTTRACE(sum(rec_obs(p)),sum(value(rec_pred(p))),sum(mat.total_pred_catch(0)))
				mat.dvarDensity(p+1).initialize();
				tagpop_age_solve(p,t_count).initialize();

				//append to the aggregated predictions and observations
				rec_obs_like  += elem_prod(rec_obs(p),tlib_obs(p));
				rec_pred_like += elem_prod(rec_pred(p),tlib_obs(p));
				//rec_obs_like  += rec_obs(p);
				//rec_pred_like += rec_pred(p);
				//cout << norm(tlib_obs(p)) << " " << sum(rec_obs_like)<< " " << sum(value(rec_pred_like)) << endl;
/*		
				//1. Concentrated
				taglike += value(norm2(rec_obs(p)-rec_pred(p)));
				likelihood += norm2(rec_obs(p)-rec_pred(p));
*/
/*				//2. Poisson
				double sf = 100.0;
				for (int ii=0; ii<nx_obs; ii++){
					for (int jj=0; jj<ny_obs; jj++){
						dvariable pred = sf*rec_pred(p,ii,jj);
						const double obs = sf*rec_obs(p,ii,jj);
						if (pred>0){
							likelihood += pred - obs*log(pred) + gammln(obs+1.0);
							taglike += value(pred - obs*log(pred) + gammln(obs+1.0));
						}
					}
				}
*/	
				//3. Weighted Logarithmic
				//spatial 2d
				//int nb_obs = sum(rec_obs(p));
				//const int ww = 2.0;
/*				double sf = ww*(1.0-nb_obs/(5.0+nb_obs));
				taglike += sf*value(norm2(log(rec_obs(p)+1e-1)-log(rec_pred(p)+1e-1)));
				likelihood += sf*norm2(log(rec_obs(p)+1e-1)-log(rec_pred(p)+1e-1));
*/				//1d (by lontigude and by latitude)
/*				dvector obs_lon = rowsum(rec_obs(p));
				dvector obs_lat = colsum(rec_obs(p));
				dvar_vector pred_lon = rowsum(rec_pred(p));
				dvar_vector pred_lat = colsum(rec_pred(p));
		                taglike += 0.5*ww*(value(norm2(obs_lon-pred_lon)+norm2(obs_lat-pred_lat)));
		        	likelihood += 0.5*ww*(norm2(obs_lon-pred_lon)+norm2(obs_lat-pred_lat));
*/
		
				if (writeoutputfiles){
//			TRACE(trans(rec_obs(p)))
				     if (!param->gcalc()){
		
					ofstream wtxt;
					std::ostringstream ostr;
					ostr << year;
					if (month>9) ostr << month <<15;
					else
						ostr << 0 << month <<15;
					string file_out = "./" + param->sp_name[0] + "_tags_pred_"  + ostr.str() + ".txt";
					wtxt.open(file_out.c_str(), ios::out);
					
					if (wtxt){
						wtxt << xlon << endl;
						wtxt << ylat << endl;
						wtxt << trans(value(rec_pred(p))) << endl;
						//wtxt << trans(value(elem_prod(rec_pred(p),tlib_obs(p))))<<endl;
					}
					wtxt.close();
			
					file_out = "./" + param->sp_name[0] + "_tags_obs_"  + ostr.str() + ".txt";
					//file_out = "./" + param->sp_name[0] + "_releases_obs_"  + ostr.str() + ".txt";
					wtxt.open(file_out.c_str(), ios::out);
					if (wtxt){
						wtxt << xlon << endl;
						wtxt << ylat << endl;
						wtxt << trans(rec_obs(p)) << endl;
						//wtxt << trans(elem_prod(rec_obs(p),tlib_obs(p))) <<endl;
					}
					wtxt.close();
			
				    }
				}
		   	    }
			}

			if ((t_count>t_count_rec[0]) && (month==3 || month==6 || month==9 || month==12)){
				//spatial 2d
			//* Note, the comments denoted '//*' is the code of SKJ taglike (verion J)
				int nb_obs = sum(rec_obs_like);
				//const float ww = 0.01; //use it if TL weight are off
				const float ww = 5e-5;//20201215: increasing weight to 5e-4 for CLT experiments
				//double sf = 1.0;
				//double sf = ww*(1.0-nb_obs/(5.0+nb_obs));
				//taglike += sf*value(norm2(log(rec_obs_like+1e-4)-log(rec_pred_like+1e-4)));
//*				taglike += ww*value(norm2(rec_obs_like-rec_pred_like));
				//taglike += sf*value(norm2(log(rec_obs_like+1.0)-log(rec_pred_like+1.0)));
				//cout << sf << " " << log(rec_obs_like+1e-1) << " "<< log(rec_pred_like+1e-1)<<" " << taglike << endl;
				//likelihood += sf*norm2(log(rec_obs_like+1e-4)-log(rec_pred_like+1e-4));
//*				likelihood += ww*norm2(rec_obs_like-rec_pred_like);
				//likelihood += sf*norm2(log(rec_obs_like+1.0)-log(rec_pred_like+1.0));
				//1d (by lontigude and by latitude)
		/// comment this for e2
		
				dvector obs_lon = rowsum(rec_obs_like);
				dvector obs_lat = colsum(rec_obs_like);
				dvar_vector pred_lon = rowsum(rec_pred_like);
				dvar_vector pred_lat = colsum(rec_pred_like);	
		                taglike += ww*(value(norm2(obs_lon-pred_lon)+norm2(obs_lat-pred_lat)));
		        	likelihood += ww*(norm2(obs_lon-pred_lon)+norm2(obs_lat-pred_lat));
		
		                //taglike += (value(norm2(log(obs_lon+1)-log(pred_lon+1))+norm2(log(obs_lat+1)-log(pred_lat+1))));
		        	//likelihood += (norm2(log(obs_lon+1)-log(pred_lon+1))+norm2(log(obs_lat+1)-log(pred_lat+1)));
			}
		
		}//end of tagging data likelihood section

		//III. Fishing data likelihoods
		if ((fishing) && (t_count > nbt_building+nbstoskip) && (t_count <= nbt_no_forecast)){
			for (int sp=0; sp < nb_species; sp++){
				int k = 0;
				for (int f=0; f<nb_fishery; f++){
					if (param->mask_fishery_sp[sp][f]){
						if (param->mask_fishery_sp_like[sp][f]){
							int y = year-(int)param->save_first_yr;
							int nobs = rw.get_numrec(f,y,month);
							likelihood += like(sp,k,f,nobs);
//
//							//test: use both cpue and catch likelihoods
//							param->frq_like[sp] = 0;
//							param->cpue = 0;
//							likelihood += like(sp,k,f,nobs);
//							param->frq_like[sp] = 1;
//							param->cpue = 1;
//
						}
						k++;
					}
				}
//cout << endl;
			}
		}

//tmp: think how to make it better		
//if (param->like_types[0][0] == 7) 
//	likelihood += norm2(mat.dvarDensity(0)-0.1);
		//------------------------------------------------------//
		//		COUPLAGE THON -FORAGE			//
		//------------------------------------------------------//
		if (param->flag_coupling){
			//----------------------------------------------//
			//		FORAGE RECRUITMENT		//
			//----------------------------------------------//
			for (int n=0; n< nb_forage; n++){
				mat.forage[tcur][n] += mat.mats[n];
				sumFprime[n] = sum(DtoBcell(mat.mats[n]));
			}
			
			PredationMortality(tcur, value(Total_pop));
			
			//----------------------------------------------//
			// 	TRANSPORT + PERTE DU FORAGE		//
			//----------------------------------------------//
			for (int n=0; n< nb_forage; n++){

				AverageCurrents(tcur,n);

				SolveADRE(mat.forage(tcur),n);
			}

		}// end of flag_coupling condition

		if (writeoutputfiles){
			if (!param->gcalc())	
				ConsoleOutput(1,value(likelihood));

			// let's count only those catch which will be used in the likelihood
			if (t_count <= nbt_building+nbstoskip) SUM_CATCH = 0.0;

			WriteOutput(tcur, fishing);
			WriteFluxes();

			if (tuna_spinup && t_count == nbt_building + 60){//temporal: the nb to skip can be set through parfile
			//if (year==1977 && month==12){//temporal: the nb to skip can be set through parfile
				//cout << date_str << "Saving initial distributions for simulation skipping spinup" << endl;
				SaveDistributions(year, month);
			}
		}
		nt_dtau++;
		past_month=month;
		step_count++;
		if (qtr != past_qtr) past_qtr = qtr; 

	} // end of simulation loop


	if (writeoutputfiles) {SaveDistributions(year, month);
		cout << "total catch in optimization: " << SUM_CATCH << endl;
	}
	//if (param->tag_like[0]){
	//	delete_tag_releases();
	//}
	param->total_like = value(likelihood);
	if (!param->scalc()) // all but sensitivity analysis
		cout << "end of forward run, likelihood: " << value(likelihood)-alike-taglike-stocklike-eFlike << " " << alike << " " << taglike << " " << stocklike << " " << eFlike << endl;

	return value(likelihood);
}

dmatrix SeapodymCoupled::DtoBcell(const dmatrix var)
{
	//dmatrix Bcell(0,nbi-1,0,nbj-1); Bcell.initialize();
	dmatrix Bcell(map.imin, map.imax, map.jinf, map.jsup); Bcell.initialize();
	Bcell = var;

	const int imin = map.imin; 
	const int imax = map.imax; 
	for (int i = imin; i <= imax; i++){
		const int jmin = map.jinf[i];
		const int jmax = map.jsup[i];
		for (int j = jmin ; j <= jmax; j++){
			if (map.carte[i][j]){
				Bcell(i,j) *= cell_area/ mat.lat_correction[j];	
			}
		}
	}
	return(Bcell);
}

void SeapodymCoupled::PredationMortality(int t, dmatrix total_pop)
{
	d4_array consumption;
	consumption.allocate(0,nb_species-1);
	for (int sp=0; sp < nb_species; sp++){
		consumption[sp].allocate(a0_adult[sp],aN_adult[sp]-1);
		for (int a= a0_adult[sp]; a< aN_adult[sp]; a++){
			consumption[sp][a].allocate(map.imin, map.imax, map.jinf, map.jsup);
			consumption[sp][a].initialize();
		}
	}

	for (int n=0; n<nb_forage; n++){
		sumF_area_pred[n]	= 0;
		sumF_required_by_sp[n]	= 0;	// total de la biomasse en forage requise (predation par especes decrites)
		mean_omega_sp[n]	= 0;	// mortalite due aux especes decrites
			
		for (int sp=0; sp < nb_species; sp++){
			for (int i=1; i< nbi-1; i++){ 
				for (int j=1; j < nbj-1 ; j++){
					if (map.carte[i][j]){
						//----------------------------------------//
						// TOTAL FORAGE BIOMASS IN PREDATOR AREA  //
						//----------------------------------------//
						if (total_pop[i][j]>0){
							//units of F: g/m^2 = tones/km^2
							sumF_area_pred[n] += mat.forage[t][n][i][j];
							for (int age= a0_adult[sp]; age< aN_adult[sp]; age++){

//Inna 10/11 deleted nF_ratio (not used in the moment, to reduce number of variables allocated), to restore later if needed
								//func.nF_ratio_comp(*param, mat, map, sp, age, i, j);
								double a = param->forage_ration[sp] ;//* mat.nF_ratio[n];
								consumption(sp,age,i,j) = a;
								//units of tuna = thous. Nb per sq km translate to tones/km^2
								sumF_required_by_sp[n] += a*value(mat.dvarDensity[sp][age][i][j])*param->weight[sp][age]*0.001;
							}
						}
					}
				}
			}
			mean_omega_sp[n] = sumF_required_by_sp[n] / sumF_area_pred[n];
		} 
	}

	for (int n=0; n<nb_forage; n++){
		for (int i=1; i< nbi-1; i++){
			for (int j=1; j < nbj-1 ; j++){
				if (map.carte[i][j]){
					double F = mat.forage[t][n][i][j];
					double FR = 0; 
					//double a_bar = 0;
					for (int sp=0; sp < nb_species; sp++){
						for (int age= a0_adult[sp]; age< aN_adult[sp]; age++){		
							//units of tuna here are g/m^2 as it goes to forage eqns:
							//Nb/km^2 * W(mt) = (Nb)*1,000,000(g)/1,000,000*m^2 = g/m^2
							double a = consumption(sp,age,i,j);
							FR += a * value(mat.dvarDensity[sp][age][i][j]) * param->weight[sp][age]*0.001; 
						}
						//a_bar /= param->sp_nb_age_class_ad[sp];
					}
					double mort_by_sp  = 0; 
					//double h = 0.025;
					//mort_by_sp = a_bar* FR/(1+a_bar*h*F); //if (m>1) m=1;
					//mort_by_sp = FR; //Lotka-Volterra trophic function
					if (F>0) mort_by_sp = FR/F; //Patrick's trophic function

					mat.mortality[n][i][j] = func.function_lambda(*param,mat,n,i,j) + mort_by_sp - mean_omega_sp[n];
				}
			}
		}
	} 
}

void SeapodymCoupled::getDate(int& jday)
{
	int newyear; //(Inna 12/10/11) no need for the moment
	Date::update_time_variables(t_count, param->deltaT, param->date_mode, jday_spinup, jday, day, month, year, newyear);
	qtr  = (int) ( ((month-1)/3)+1 );
        date_str=Utilities::MakeDate(year,month,day);
}

void SeapodymCoupled::SaveIntermediate(const int sp, const int age)
{
	//save distribution to the file
	dmatrix mat2d(0, nbi - 1, 0, nbj - 1);
	mat2d.initialize();
	for (int i=map.imin; i <= map.imax; i++){
		for (int j=map.jinf[i] ; j<=map.jsup[i] ; j++){
			if (map.carte[i][j]){
				mat2d(i,j) = value(mat.dvarDensity(sp,age,i,j));
			}
		}
	}

	rw.wbin_mat2d("interm.tmp", mat2d, nbi, nbj, true);	
}


void SeapodymCoupled::SaveDistributions(const int year, const int month)
{	
	for (int sp=0; sp<nb_species; sp++){
		//write down the state vector to be used as initial condition
		string dirname = param->strdir_output;
		string date;
		std::stringstream ss;
		ss << year << "_" << month;
		ss >> date;

		//Format of IC file: single regular DYM2 file
		string fileCohorts = dirname + param->sp_name[sp] + "_cohorts" + date + ".dym";
		cout << "Saving distributions to " << fileCohorts << endl;

		///int nb_cohorts = param->sp_nb_age_class_ad[sp]+3;
		int nb_cohorts = param->sp_nb_cohorts[sp];
		double minval = .0; 
		double maxval = max(value(mat.dvarDensity(sp,0)));
		dvector zlevel(0,nb_cohorts-1);
		for (int n=0; n<nb_cohorts; n++) zlevel[n] = n+1;  
		rw.wbin_header(fileCohorts, param->idformat, param->idfunc, minval, maxval, 
					param->nlong, param->nlat, nb_cohorts, zlevel[0], zlevel[nb_cohorts -1],
					mat.xlon, mat.ylat, zlevel, mat.mask);

		SaveCohorts(fileCohorts, sp, true);
		///SaveJuvCohorts(fileCohorts, sp, true);
		///SaveAdultCohorts(fileCohorts, sp, true);
	}
}

void SeapodymCoupled::SaveCohorts(string fileout, int sp, bool FileMode)
{	
	double mult = 1.0;
	//double mult = 0.5;
	const int nb_ages= param->sp_nb_cohorts[sp];
	for (int a=0; a<nb_ages; a++){
//if (a==0) mult = 0.4;
//if (a>1) mult = 0.9;
//if (a>4) mult = 1.0;
//if (a>2) mult = 0.95;

		dmatrix mat2d(0, nbi - 1, 0, nbj - 1);
		mat2d.initialize();

		for (int i=map.imin; i <= map.imax; i++){
			for (int j=map.jinf[i] ; j<=map.jsup[i] ; j++){
				if (map.carte[i][j]){
					mat2d(i-1,j-1) = mult*value(mat.dvarDensity(sp,a,i,j));
				}
			}
		}
		rw.wbin_transpomat2d(fileout, mat2d, nbi-2, nbj-2, FileMode);

		FileMode = true;
	}
}

//this function is used in adjoint
void SeapodymCoupled::SaveAdultsTuna(string fileAdu, int sp, bool FileMode)
{		
	for (int age=a0_adult[sp]; age<aN_adult[sp]; age++){
		
		dmatrix mat2d(0, nbi - 1, 0, nbj - 1);
		mat2d.initialize();

		for (int i=map.imin; i <= map.imax; i++){
			for (int j=map.jinf[i] ; j<=map.jsup[i] ; j++){
				if (map.carte[i][j]){
					mat2d(i,j) = value(mat.dvarDensity(sp,age,i,j));
				}
			}
		}
//cout << "adult: " << age << " " <<  sum(mat2d) << endl;
		rw.wbin_mat2d(fileAdu, mat2d, nbi, nbj, FileMode);
		FileMode = true;
	}
}

/*
void SeapodymCoupled::UpdateTimeVars(int& nbt_total, int& nbt_start_series)
{
	int nbt_yr = (int) (365.25/deltaT);
	int nbt_timeseries = (int)( nbt_yr * (param->save_last_yr - param->save_first_yr) );
	nbt_total = nbt_building + nbt_timeseries + (int)(param->nb_yr_forecast/t_yrdd);
	float dec = param->save_first_yr - (int) param->save_first_yr ;
	float firstdate_rec = ((int) param->save_first_yr) + t_yrdd/2 +  ((int)(dec/t_yrdd))* t_yrdd;
	nbt_start_series = (int) ( (firstdate_rec - param->startdate) / t_yrdd + .5);
}
*/
void SeapodymCoupled::InitializeAll()
{
	t_count = nbt_building+1;
	mat.mats.initialize();
	mat.density_before.initialize();
	mat.density_after.initialize();
	mat.dvarDensity.initialize();
	mat.dvarCatch_est.initialize();
/*
//const int nba_old = 17; //skj
//const int tauvar[nba_old] = {1,2,1,1,1,1,1,1,2,2,2,3,3,4,6,5,1};//skj

const int nba_old = 19; //yft
const int tauvar[nba_old] = {1,1,1,1,1,1,1,1,2,1,2,1,2,2,3,3,4,5,1};//yft 30 30 30 60  60  60  60  60  90  90  90  90 120 120 150 180 240 300 660

	for (int sp=0; sp<nb_species; sp++){


//To redistribute cohorts from variable size to monthly:
ivector a_old(0,param->sp_nb_cohorts[sp]-1);
a_old.initialize();
int ac = 0;
for (int a=0; a<nba_old; a++){
	for (int n=0; n<tauvar[a]; n++){
		a_old[ac] = a;
		ac++;
	}
}
cout << a_old << endl;
*/
	for (int sp=0; sp<nb_species; sp++){
		double sfactor = 1.0;
		const int nb_ages = param->sp_nb_cohorts[sp];	
		for (int a=0; a<nb_ages; a++){
sfactor = 1.0;
//if (a<12) sfactor = 0.8;
//if (a>=12) sfactor = 1.6;
//if (a<3) sfactor = 0.5;
//if (a==2) sfactor = 1.0;
			mat.dvarDensity(sp,a) = sfactor*mat.init_density_species(sp,a);
//To redistribute quarterly cohorts to monthly:
//			int aage = (int) a/4;//3;
//			mat.dvarDensity(sp,a) = mat.init_density_species(sp,aage)/4;//3;
//			if (a==nb_ages-1) 
//				mat.dvarDensity(sp,a) = mat.init_density_species(sp,aage);
//To redistribute cohorts from variable size to const size:
//			mat.dvarDensity(sp,a) = mat.init_density_species(sp,a_old[a])/tauvar[a_old[a]];
//cout << "COHORT " << a << " : " <<  norm(value(mat.dvarDensity(sp,a))) << endl;
		}
	}
}
	

void SeapodymCoupled::AverageCurrents(int t, int n){
	// return the (u,v) current which transports the forage component
	// non migrant : current in the layer
	// migrant : average current relative to time spent in day and night layers
	if (param->day_layer[n]==param->night_layer[n]){ //non migrant forage
		int dn_lay=param->day_layer[n];
		for (int i=1;i<nbi-1;i++){
			for (int j=1;j<nbj-1;j++){
				if (map.carte[i][j]){
					mat.u[i][j]= mat.un[t][dn_lay][i][j];
					mat.v[i][j]= mat.vn[t][dn_lay][i][j];
				}
			}
		}
	} 
	else {//migrant forage
		int d_lay=param->day_layer[n];
		int n_lay=param->night_layer[n];
		for (int i=1;i<nbi-1;i++){
			for (int j=1;j<nbj-1;j++){
				if (map.carte[i][j]){
					double DL = mat.daylength[i][j];
					mat.u[i][j] = ((DL * mat.un[t][d_lay][i][j]) + ((24-DL)*mat.un[t][n_lay][i][j]) ) / 24 ;
					mat.v[i][j] = ((DL * mat.vn[t][d_lay][i][j]) + ((24-DL)*mat.vn[t][n_lay][i][j]) ) / 24 ;
				}
			}
		}
	}
}

void SeapodymCoupled::SolveADRE(d3_array F, int n)
{
	pop.precaldia(*param, map, mat);
	pop.caldia(map, *param, mat.diffusion_x, mat.advection_x, mat.diffusion_y, mat.advection_y);

	pop.precalrec(map, mat.mortality[n]);
	pop.calrec(map, F[n], mat.mortality[n]);
}

void SeapodymCoupled::CalcMeanTemp(const int t_count, const int tcur)
{// only in simulation mode: compute mean temperature at age
	if (!param->gcalc()){
	if (t_count == 1){
		for (int sp = 0; sp < nb_species; sp++){
			for (int age = 0; age < aN_adult(sp); age++) 
				if (age < a0_adult(sp))
					mat.mean_temperature(sp,age) = param->b_sst_spawning[sp];
				else
					mat.mean_temperature(sp,age) = param->temp_age[sp][age];
		}
	}
	else {
		for (int sp = 0; sp < nb_species; sp++){
			//For larvae and juveniles:
			mat.MeanVarTemperature(map,sp,param->sp_nb_cohort_lv[sp], a0_adult[sp],tcur);

			//Adult cohorts
			for (int age = a0_adult(sp); age < aN_adult(sp); age++) 
				mat.mean_temperature(sp,age) = func.Tmean_comp(*param,mat,map,sp,age,tcur);
		}
	}
	}
}

void SeapodymCoupled::CalcSums()
{
	mat.larvae.initialize();
	mat.juvenile.initialize();
	mat.young.initialize();
	mat.recruit.initialize();
	mat.adult.initialize();
	mat.total_pop.initialize();
	mat.total_pred_catch.initialize();
	if (!param->tags_only){
		mat.total_obs_catch.initialize();
	}
	mat.sum_B_larvae.initialize();
	mat.sum_B_juv.initialize();
	mat.sum_B_young.initialize();
	mat.sum_B_recruit.initialize();
	mat.sum_B_adult.initialize();
	mat.sum_total_pop.initialize();
	
//temporal: test
	double sum_total_catch = 0;

double lon_east = 90.0;
double lat_south = -55.0;

if (param->sp_name[0].find("skj")==0){
	//lon_east = 135.5;
	//lat_south = -12;
	lon_east = lon_east;
	lat_south = lat_south;
}

if (param->sp_name[0].find("bet")==0){
	lon_east = 120;
	lat_south = -10;
}


if (param->sp_name[0].find("swo")==0){
	//lon_east = 91.5;
	//lat_south = -28;
	lon_east = 114.5;
	lat_south = -22;
}

if (param->sp_name[0].find("yft")==0){
	lon_east = 91.0;
	lat_south = 22.0;	
}

if (param->longitudeMin<80) //IO domain
	lon_east = 0.0;

//int ilim = param->lontoi(lon_east);
//int jlim = param->lattoj(lat_south);

	//------------------------------------------------------------------
	//Note, All population stages will be stored in the units of density:
	//Nb/km2 for stages Juv - Rercruits, tonnes/km2 for young - adults
	//------------------------------------------------------------------
	for (int sp=0; sp < nb_species; sp++){
		dvector W_mt;
		W_mt.allocate(0,aN_adult[sp]-1); 
		for (int age=0; age<aN_adult(sp); age++){
			W_mt[age] = param->weight[sp][age] * 0.001;
		}

		const int age_recruits = param->age_recruit[sp];
		const int nb_lv = param->sp_nb_cohort_lv[sp];
		for (int i=map.imin; i <= map.imax; i++){
			for (int j=map.jinf[i] ; j<=map.jsup[i] ; j++){
        			if (map.carte[i][j]){
        			//if (map.carte[i][j] && !(i<=ilim && j>=jlim)){

//test: to compare B with MFCL (simulation mode only, doesn't affect optimization)
//for (int age=0; age<aN_adult[sp]; age++){
//	if (i<ilim && j>jlim){ mat.dvarDensity[sp][age][i][j] = 0.0;}
//}
//if (i>=61) nbcells++;

					double lat_corrected_area = cell_area / mat.lat_correction[j];
					//test:
					//double lat_corrected_area = param->cell_surface_area(j);
					//-----------------------------------------------------------
					// Larvae = age 0
					// units = Nb/km^2 
					// UNITS = (Nb/km^2) * W(mt) * cell_area(km^2) = TONNES over all domain
					//------------------------------------------------------------
					for (int age= 0; age<nb_lv; age++){
						mat.larvae[sp][i][j] = value(mat.dvarDensity[sp][age][i][j]);
						mat.sum_B_larvae[sp] +=  value(mat.dvarDensity[sp][age][i][j])*W_mt(age)*lat_corrected_area;
						//mat.sum_B_larvae[sp] +=  value(mat.dvarDensity[sp][age][i][j]) *lat_corrected_area;
					}
					//-----------------------------------------------------------
					// Juveniles  = age  1 to age_autonomous (1st quarter)
					// biomass = sum n*weight by age class 
					// UNITS = (Nb/km^2) * W(mt) = tonnes/km^2, UNITS of sum = TONNES over entire domain
					//------------------------------------------------------------
					for (int age=nb_lv; age<a0_adult[sp]; age++){
					//for (int age=nb_lv; age< age_recruits; age++){
						mat.juvenile[sp][i][j] += value(mat.dvarDensity[sp][age][i][j]); //in numbers as larvae
						mat.sum_B_juv[sp] += value(mat.dvarDensity[sp][age][i][j])*W_mt(age)*lat_corrected_area;
						//mat.sum_B_juv[sp] += value(mat.dvarDensity[sp][age][i][j])*lat_corrected_area;
					}
					//for (int age= 1; age < param->sp_nb_age_class_jv[sp]; age++){
						//mat.juvenile[sp][i][j] += value(mat.dvarJuv_species[sp][age][i][j]) * param->juv_weight[sp][age];
					//mat.sum_B_juv[sp] += mat.juvenile[sp][i][j]*area/mat.lat_correction[j];
					//-----------------------------------------------------------
					// recruit = age  at recruitment
					// biomass = sum n*weight by age class 
					// numbers per sq.km per month 
					// UNITS = (Nb/km^2) * W(mt) = tonnes/km^2, UNITS of sum = TONNES over entire domain
					//------------------------------------------------------------
					if (!param->tag_like[sp]){
						for (int age= age_recruits-1; age<= age_recruits+1; age++){//MFCL qtr class
							mat.recruit[sp][i][j] += value(mat.dvarDensity[sp][age][i][j]); //in numbers/sq.km
							//for SumDym write weight
							mat.sum_B_recruit[sp] += value(mat.dvarDensity[sp][age][i][j])*W_mt(age)*lat_corrected_area;//total number
						}
					}
					if (param->tag_like[sp]){
						for (int aa=a0_adult[sp]; aa<aN_adult[sp]; aa++){
							double total_tags = 0.0;
							for (int pop=1; pop<=param->nb_tag_files;pop++)
								total_tags += value(mat.dvarDensity(pop,aa,i,j));

							mat.recruit[0][i][j] += total_tags; 
//if (value(mat.dvarDensity(1,aa,i,j))<0) cout << "ERROR LOCATED for " << aa << " " << 	value(mat.dvarDensity(1,aa,i,j)) << endl;
						}
					}
					//mat.sum_B_recruit[sp] += value(mat.dvarDensity[sp][age_recruits][i][j])*W_mt(age_recruits)*lat_corrected_area;
					//-----------------------------------------------------------
					// (Young) = age  autonomous to age mature
					// ADULT TUNA = tuna biomass from age of maturity
					// biomass = sum n*weight by age class 
					// UNITS = (Nb/km^2) * W(mt) = tonnes/km^2, UNITS of sum = TONNES over entire domain
					//------------------------------------------------------------
					for (int age= a0_adult[sp]; age<aN_adult[sp]; age++){
						if (param->maturity_age[sp][age]<0.5)
							mat.young[sp][i][j] += value(mat.dvarDensity[sp][age][i][j]) * W_mt[age];// * swa(sp,age);
						else 
							mat.adult[sp][i][j] += value(mat.dvarDensity[sp][age][i][j]) * W_mt[age];// * swa(sp,age);
					
					//	mat.young[sp][i][j] += (1-param->maturity_age[sp][age])*value(mat.dvarDensity[sp][age][i][j]) * W_mt[age];// * swa(sp,age);
					//	mat.adult[sp][i][j] += param->maturity_age[sp][age]*value(mat.dvarDensity[sp][age][i][j]) * W_mt[age];// * swa(sp,age);
					}
					mat.sum_B_young[sp] += mat.young[sp][i][j] * lat_corrected_area;
					mat.sum_B_adult[sp] += mat.adult[sp][i][j] * lat_corrected_area;
					//----------------------------------------------------------
					// TOTAL TUNA BIOMASS feeding on the forage
					// sum n * weight by age class
					// UNITS = tonnes/km^2, UNITS of sum = TONNES over entire domain
					//----------------------------------------------------------
					mat.total_pop[sp][i][j] = mat.young[sp][i][j] + mat.adult[sp][i][j];
					mat.sum_total_pop[sp] += mat.total_pop[sp][i][j] * lat_corrected_area;

					//----------------------------------------------------------
					// TOTAL OBSERVED AND PREDICTED CATCH FOR SPECIES
					// UNITS = tonnes/cell
					//----------------------------------------------------------
					if (!param->tags_only){//in this simulations will write obs and pred tag numbers,
							//so this loop should be omited
						int k=0; int nbe = 0; 
						for (int f=0; f<nb_fishery; f++){					
							if (param->mask_fishery_sp[0][f]){
							//test converting Nb to mt with mean weight in simulation mode
	                                                //Attn, will affect likelihood computation
	                                            /*    string fishery_name = param->list_fishery_name[f];
	                                                if (fishery_name.find("L")==0){
	                                                        mat.catch_obs[sp][k][i][j] *= 0.03;
	                                                        mat.catch_est[sp][k][i][j] *= 0.03;
	                                                }*/
							
							    if (mat.effort[f][i][j]){

								mat.total_obs_catch[sp][i][j]  += 
									mat.catch_obs[sp][k][i][j];
 
								mat.total_pred_catch[sp][i][j] += 
									mat.catch_est[sp][k][i][j];	

								nbe++;
							    } k++;
							}
						}
					}	

					//to distinguish between 0 catch and no fishing events.
//					if (nbe==0) {
//						mat.total_obs_catch[sp][i][j]  = -1;
//						mat.total_pred_catch[sp][i][j] = -1;	
//					}

					sum_total_catch += mat.total_obs_catch[sp][i][j]; 
					//sum_total_catch += mat.total_pred_catch[sp][i][j]; 
					
				}
			}
		}
	}
//cout << nbcells << " "<< nbcells*area/param->juv_weight[0][0] << endl; exit(1);
SUM_CATCH += sum_total_catch;
}

void SeapodymCoupled::ConsoleOutput(int flag_simulation, double like)
{
        if (flag_simulation){
                cout << setw(4)  << left << t_count<<"| "
                     << setw(14) << date_str<<"| "
                     << setw(14) << mat.sum_B_larvae[0]<<" | "
                     << setw(14) << mat.sum_B_juv[0]<<" | "
                     << setw(14) << mat.sum_B_young[0]<<" | "
                     << setw(14) << mat.sum_B_adult[0]<<" | "
                     << setw(14) << mat.sum_total_pop[0]<<" | "
                     << like << endl;
        }
        else{
                //CalcSums();
                // Comment: Larvae biomass is the result of spawning function S(t-1) and ADRE at time t
                // we have Larvae(t=1)=0 because S(t-1) is computed after CalcSums()
                cout << endl << "Model temporal dynamics:" << endl;
                cout << setw(4)  << left << "step"<<"| "
                     << setw(14) << "Date"<<"| "
                     << setw(14) << "Larvae"<<" | "
                     << setw(14) << "Juveniles"<<" | "
                     << setw(14) << "Young"<<" | "
                     << setw(14) << "Adult"<<" | "
                     << setw(14) << "Total_pop"<<" | "
                     << setw(14) << "Likelihood"<< endl;

                cout << "----------------------------------------------------------------------------------------------------------"<< endl;
        }
}

void SeapodymCoupled::SolveADE(d4_array S, int n, int ntimes)
{
	pop.precaldia(*param, map, mat);

	pop.caldia(map, *param, mat.diffusion_x, mat.advection_x, mat.diffusion_y, mat.advection_y);

	pop.precalrec(map,mat.mortality[n]);

	for (int nbt = 0; nbt < ntimes; nbt++){		
		// call "calrec"  for transport of source matrices from 0 to Tr_max 
		pop.calrec(map, S[n][nbt], mat.mortality[n]);
	}
}


/*
//to save deistribution before catch event
fishing = false;
dvar3_array Pop_copy;
const int agemax_ad = param->sp_nb_cohorts[0];
Pop_copy.allocate(0, agemax_ad - 1);
for (int age = 0; age < agemax_ad; age++) {
	Pop_copy(age).allocate(map.imin1, map.imax1, map.jinf1, map.jsup1);
	Pop_copy(age).initialize();
}
Pop_copy = mat.dvarDensity[0];

// regular block with habitat computation and caldia-calrec

//==================================//
//=== starting loop with fishing ===//
//==================================//
fishing = true;
mat.dvarDensity[0].initialize();
mat.dvarDensity[0] = Pop_copy;

// regular block with habitat computation and caldia-calrec

//==================================//
//===  ending loop with fishing  ===//
//==================================//
*/

/*
//checking if there is negative biomass
bool flag_exit = false;
const int imin = map.imin; 
const int imax = map.imax; 
for (int i = imin; i <= imax; i++){
	const int jmin = map.jinf[i];
	const int jmax = map.jsup[i];
	for (int j = jmin ; j <= jmax; j++){
		if (map.carte[i][j]){
double B = value(mat.dvarPop_species(sp,age,i,j));
if (B<0) {cout<< age << " " << i << " " << j << " " << value(Mortality(age,i,j)) << " " << B;   flag_exit = true;}
}}}
if (flag_exit) exit(1);
*/


#include "calpop.h"

/// Forward functions for:
/// computing total exploited biomass at age, which is used to split the
/// observed catch of fisheries without effort data among age classes,
/// and then used in computation of predicted catch without effort

void CCalpop::total_exploited_biomass_comp(
    const imatrix carte, const dmatrix& uu, const dmatrix& Cobs, const int f,
    const int fne, const int age, const int sp) {
    for (int j = b.rowmin(); j <= b.rowmax(); j++) {
        for (int i = b[j].indexmin(); i <= b[j].indexmax(); i++) {
            if (carte(i, j) && Cobs(i, j)) {
                dvarsSNsum(fne).elem_value(i, j) +=
                    Selectivity(sp, f, age) * uu(i, j);
            }
        }
    }
}

void CCalpop::Recomp_total_exploited_biomass(
    const PMap& map, CParam& param, CMatrices& mat, dmatrix& EB,
    const dmatrix& Cobs, const dvector& selectivity, const int f, const int sp,
    const int t_count) {
    const int a0 = param.sp_a0_adult[sp];
    const int nb_ages = param.sp_nb_cohorts[sp];
    dmatrix uu;
    uu.allocate(map.imin1, map.imax1, map.jinf1, map.jsup1);

    EB.initialize();
    for (int age = a0; age < nb_ages; age++) {
        uu.initialize();
        uu = mat.density_before(sp, t_count, age);

        for (int i = map.imin; i <= map.imax; i++) {
            const int jmin = map.jinf[i];
            const int jmax = map.jsup[i];
            for (int j = jmin; j <= jmax; j++) {
                if (map.carte(i, j) && Cobs(i, j)) {
                    EB(i, j) += selectivity(age) * uu(i, j);
                }
            }
        }
    }
}

void CCalpop::Selectivity_comp(
    CParam& param, const int nb_fishery, const int a0, const int nb_ages,
    const int sp) {
    int k = 0;
    for (int f = 0; f < nb_fishery; f++) {
        if (param.mask_fishery_sp[sp][f]) {
            for (int age = a0; age < nb_ages; age++) {
                Selectivity(sp, f, age) = param.selectivity_comp(sp, age, f, k);
            }
            k++;
        }
    }
}
